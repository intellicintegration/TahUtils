from enum import Enum
from typing import Any, Union, Optional
from abc import ABC, abstractmethod
from tahutils.tahu import sparkplug_b as spb
from tahutils.types import MetricName, MetricTimes, MetricValues
from tahutils.utils import convert_enum_keys, flatten_data_dict, process_times, make_key, dataclass_to_dict, instance_to_dict
from tahutils.topic import SpbTopic
from dataclasses import is_dataclass, dataclass, fields
from tahutils import datatypes

# Enum and constants
class CommandMetric(Enum):
	NextServer = "Node Control/Next Server"
	Rebirth = "Node Control/Rebirth"
	Reboot = "Node Control/Reboot"

COMMAND_METRICS_SET = {m.value for m in CommandMetric}
_UNSET = object()

# Abstract Base Class
class BaseSpbNode(ABC):
	def __init__(
			self,
			use_aliases: bool = False,
			auto_serialize: bool = True,
			serialize_cast: Optional[callable] = bytearray,
			flattened_dict_delimiter: str = "/",
			topic: SpbTopic = None,
	) -> None:
		self._use_aliases = use_aliases
		self.auto_serialize = auto_serialize
		self.serialize_cast = serialize_cast
		self.flattened_dict_delimiter = flattened_dict_delimiter
		self.topic = topic

		self._last_death = None

	@property
	def is_aliasing(self) -> bool:
		"""Returns whether aliases are being used"""
		return self._use_aliases

	@property
	def last_death(self) -> bytes:
		"""Returns the last death payload generated by the model"""
		return self._last_death

	@property
	def is_device(self) -> bool:
		"""Returns whether the model is a device"""
		if self.topic is None:
			raise ValueError("No topic set for this model")
		return self.topic.is_device

	def _serialize(self, p: spb.Payload) -> Union[bytes, spb.Payload]:
		"""Serializes the payload if auto_serialize is True, otherwise is a no-op."""
		if self.auto_serialize:
			if self.serialize_cast is not None:
				return self.serialize_cast(p.SerializeToString())
			return p.SerializeToString()
		return p

	def aliasToMetric(self, alias: int) -> str:
		"""Returns the metric for the given alias. Raises a ValueError if aliases are not being used."""
		if not self._use_aliases:
			raise ValueError("Aliases are not being used")
		return self._alias_to_metric[alias]

	def metricToAlias(self, metric: str) -> int:
		"""Returns the alias for the given metric. Raises a ValueError if aliases are not being used."""
		if isinstance(metric, Enum):
			metric = metric.value
		if not self._use_aliases:
			raise ValueError("Aliases are not being used")
		return self._metric_to_alias[metric]

	@abstractmethod
	def getDeathPayload(self):
		"""Abstract method to return a death payload."""
		pass

	@abstractmethod
	def getBirthPayload(self, state: MetricValues, times: MetricTimes = dict(), rebirth: bool = False, ignore_missing_node_death: bool = False):
		"""Abstract method to return a birth payload."""
		pass

	@abstractmethod
	def getDataPayload(self, state: MetricValues, times: MetricTimes = dict()):
		"""Abstract method to return a data payload."""
		pass


# DictSpbNode Class
class DictSpbNode(BaseSpbNode):
	def __init__(
			self,
			metrics: dict[MetricName, spb.MetricDataType],
			use_aliases: bool = False,
			auto_serialize: bool = True,
			serialize_cast: Optional[callable] = bytearray,
			flatten_states: bool = True,
			flattened_dict_delimiter: str = "/",
			is_device=False,
			topic: SpbTopic = None,
	) -> None:
		super().__init__(
			use_aliases=use_aliases,
			auto_serialize=auto_serialize,
			serialize_cast=serialize_cast,
			flattened_dict_delimiter=flattened_dict_delimiter,
			topic=topic,
		)
		if is_dataclass(metrics):
			metrics = dataclass_to_dict(metrics)

		self.flatten_states = flatten_states
		self.flattened_dict_delimiter = flattened_dict_delimiter

		metrics = self._preprocess_dict(metrics)
		self.metrics = set(metrics.keys())
		self.metric_types = {k: v for k, v in metrics.items()}
		if not self.is_device:
			self.metric_types |= {m: spb.MetricDataType.Boolean for m in COMMAND_METRICS_SET}

		self.current_values = {}

		self._use_aliases = use_aliases
		if self.is_device:
			self.all_metrics = self.metrics
		else:
			self.all_metrics = COMMAND_METRICS_SET | self.metrics
		self._metric_to_alias = {metric: i for i, metric in enumerate(self.all_metrics)} \
			if self._use_aliases else \
			{metric: None for metric in self.all_metrics}

		self._alias_to_metric = {i: metric for i, metric in self._metric_to_alias.items()} \
			if self._use_aliases else None

		self.auto_serialize = auto_serialize
		self.serialize_cast = serialize_cast

		self.node_death_requested = self.is_device

		self._last_death = None

	def get(self, *args) -> Any:
		key = make_key(*args, delimiter=self.flattened_dict_delimiter)
		return self.current_values.get(key, None)

	def _preprocess_dict(self, state: MetricValues, is_time: bool = False) -> MetricValues:
		"""Preprocesses the state, flattening it if enabled, and converting enum keys. Can optionally preprocess times."""
		if is_dataclass(state):
			state = instance_to_dict(state)
		r = flatten_data_dict(state, delimiter=self.flattened_dict_delimiter) if self.flatten_states else convert_enum_keys(state)
		if is_time:
			r = process_times(r)
		return r

	def getDeathPayload(self):
		"""Returns a death payload for the node."""
		self.node_death_requested = True
		self._last_death = self._serialize(spb.getDdataPayload() if self.is_device else spb.getNodeDeathPayload())
		return self._last_death

	def getBirthPayload(self, state: MetricValues, times: MetricTimes = dict(), rebirth: bool = False, ignore_missing_node_death: bool = False):
		"""Returns a birth payload for the given state."""
		state = self._preprocess_dict(state)
		times = self._preprocess_dict(times, is_time=True)

		if not ignore_missing_node_death and not self.node_death_requested:
			raise ValueError("Must request death before requesting new birth")
		expected_keys = set(state.keys()) if self.is_device else set(COMMAND_METRICS_SET | state.keys())
		if not rebirth and set(expected_keys) != set(self.all_metrics):
			raise ValueError("Node birth metrics must be the same as the model's metrics")

		payload = spb.getDeviceBirthPayload() if self.is_device else spb.getNodeBirthPayload()

		if not self.is_device:
			for metric in COMMAND_METRICS_SET:
				if metric not in state:
					state[metric] = False

		for metric, value in state.items():
			mt = self.metric_types[metric]
			self.current_values[metric] = value

			if metric in times:
				spb.addMetric(payload, metric, self._metric_to_alias[metric], mt, value, metric[times])
			else:
				spb.addMetric(payload, metric, self._metric_to_alias[metric], mt, value)

		if rebirth:
			for metric in set(self.current_values.keys()).difference(state.keys()):
				value = self.current_values[metric]
				mt = self.metric_types[metric]

				spb.addMetric(payload, metric, self._metric_to_alias[metric], mt, value)

		return self._serialize(payload)

	def getDataPayload(self, state: MetricValues, times: MetricTimes = dict()):
		"""Returns a data payload for the given state."""
		state = self._preprocess_dict(state)
		times = self._preprocess_dict(times, is_time=True)

		if not set(state.keys()).issubset(set(self.all_metrics)):
			raise ValueError("Node data metrics must be a subset of the model's metrics")

		payload = spb.getDdataPayload()

		for metric, value in state.items():
			if value != self.current_values.get(metric, ...):
				mt = self.metric_types[metric]
				self.current_values[metric] = value

				if metric in times:
					spb.addMetric(payload, metric, self._metric_to_alias[metric], mt, value, times[metric])
				else:
					spb.addMetric(payload, metric, self._metric_to_alias[metric], mt, value)

		return self._serialize(payload)


# DataclassSpbNode Class
class DataclassSpbNode(BaseSpbNode):
	def __init__(
			self,
			model_class,
			topic: SpbTopic = None,
			use_aliases: bool = False,
			auto_serialize: bool = True,
			serialize_cast: callable = bytearray,
	):
		if not is_dataclass(model_class):
			raise ValueError("model_class must be a dataclass")
		self._model = self.fill_with_unset(model_class)
		self.last_published = None
		self.topic = topic
		self.child_devices = set()
		self._use_aliases = use_aliases

	@property
	def is_device(self):
		if self.topic is None:
			raise ValueError("No topic set for this model")
		return self.topic.is_device

	@property
	def model(self):
		return self._model

	def fill_with_unset(self, cls):
		if not is_dataclass(cls):
			raise ValueError("The provided class is not a dataclass")

		field_values = {}
		for field in fields(cls):
			field_type = field.type
			if is_dataclass(field_type):
				field_values[field.name] = self.fill_with_unset(field_type)
			else:
				field_values[field.name] = _UNSET
		return cls(**field_values)

	def getDeathPayload(self):
		"""Returns a death payload for the dataclass node."""
		self._last_death = self._serialize(spb.getNodeDeathPayload())
		return self._last_death

	def getBirthPayload(self, state: MetricValues, times: MetricTimes = dict(), rebirth: bool = False, ignore_missing_node_death: bool = False):
		"""Returns a birth payload for the dataclass node."""
		payload = spb.getNodeBirthPayload()
		return self._serialize(payload)

	def getDataPayload(self, state: MetricValues, times: MetricTimes = dict()):
		"""Returns a data payload for the dataclass node."""
		payload = spb.getDdataPayload()
		return self._serialize(payload)
